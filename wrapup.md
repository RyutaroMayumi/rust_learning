# RUST言語のまとめ

## RUSTはデータオリエンテッドな言語？
- 通常の言語では、一つの名前に対して、一つの値を割り当てるが、RUSTでは、一つの値に対して、一つの名前を割り当てる。これを変数束縛という。
    - （従来）メモリ番地に名前を付ける
    - （RUST）データに名前を付ける
- ここからは想像
    - この性質は、記憶と演算を同時に実行できる素子（メモリスターやアトムトランジスタなど）において、重要な意味を持つと考えられる。
    - なぜなら、記憶専用の素子がなくなることにより、記憶対象のデータとその操作を合わせて管理する必要があるため。
    - 「メモリ番地XXXXの値をxxする」というような従来のアーキテクチャから、「データAをxxする」のように変わると考えられる。
## RUSTは変数宣言では型推論を行う
- ただし、関数の引数では型推論を行わず、型宣言を強制する。
- 従来の完全な型宣言方式と完全な型推論方式の中間を採用している。
    - RUSTの変数はデフォルトでイミュータブル（const）になっている
    - RUSTでは初期化されていない変数は使用できない
    - RUSTでは、
        ```
        let x: i32 = 8;
        ...
        let x = 12;
        ```
        のようなシャドーイングは、代入を意味するのではなく、束縛の上書きとなる。（おそらく、名前xがさしているメモリ番地が変わる。）また、
        ```
        let mut x: i32 = 1;
        ...
        x = 7;
        ```
        のようなシャドーイングでは代入が行われる？
## RUSTのプログラムには少なくとも一つの関数が含まれる
- 関数は以下のように定義される
    ```
    fn main() {
    }
    ```
## RUSTでは自作関数を次のように定義する
- 関数はただ一つの値を返し、関数の最後の行が何を返すのかを決定する。
    ```
    fn add(x: i32, y: i32) -> i32 {
        x + y
    }
    ```
## RUSTには2つの文「宣言文」と「式文」がある
- 変数を束縛するletキーワードは宣言であり、文の先頭でのみ使用でき、その文は宣言文となる。
- 宣言文以外は式文である。
- RUSTでは、文の後ろには文が続くことが期待され、セミコロン（;）が文と文を区切るために使用される。
    そのため、
    ```
    fn add(x: i32, y: i32) -> i32 {
        x + y;
    }
    ```
    の記述は"x + y"の次に空の文が接続されていると解釈され、戻り値の型不一致によりコンパイルエラーとなる。
## 早期リターン
- returnキーワードを使うことで、関数の最後の文より前に、関数を終了して値を返すことができる。
- したがって、return文の後にセミコロンがあっても、コンパイルエラーにはならない。
    ⇒　なぜなら、return文で関数が終了するため、その後ろの空の文は実行されず、戻り値の型不一致が発生しないからである。
## RUSTには、値を返さない関数が存在する
- 戻り値の型のエクスクラメーション（!）は値を返さない；diverges型の値（!）を返す；ことを意味する。
    ```
    fn diverges() -> ! {
        panic!("This function never returns!");
    }
    ```
## 関数を指示する変数束縛を作る（関数ポインタ）こともできる
```
fn foo(i: i32) -> i32 {
    i * 2
}

let f: fn(i32) -> i32 = foo;  // with type inference
let f = foo;                  // without type inference
let bar = f(5);
```
## データ型の種類
- プリミティブ型：すべてのデータ型はプリミティブ型の上に構築される
- ブーリアン型：trueとfalseの二値
    ```
    let x = true;
    let y: bool = false;
    ```
- char型：ユニコード（4バイト）のスカラ値。シングルクォートで囲む。
    ```
    let x = 'x';
    let two_hearts = '💕';
    ```
- 数値型：符号あり/符号なし、固定長/可変長、浮動小数点数/整数の組み合わせからなる数値
    - 符号あり整数：i8, i16, i32, i64
    - 符号なし整数：u8, u16, u32, u64
    - ポインタサイズ：isize, usize
    - 浮動小数点数：f32, f64
    ```
    let x: i32 = 1;
    let y: f32 = 1.0;
    ```
- リスト型：他のデータ型のシーケンスを表現する
    - 配列：固定長の同じ型の要素のリスト。デフォルトではイミュータブル。
        型とサイズはT記法 [T; N] (T:型, N:サイズ) で表現される。
        配列へのアクセスは実行時に範囲チェックされる（範囲外へのアクセスは実行時エラーになる）
        ```
        // 各要素で初期化
        let a = [1, 2, 3];        // a: [i32; 3]
        let mut m = [1, 2, 3];    // m: [i32; 3]
        // 同じ値で初期化
        let a = [0; 20];          // a: [i32; 20]
        ```
    - スライス：配列の部分配列への参照（ビュー）。ミュータブルにもできる。
        ```
        let a = [0, 1, 2, 3, 4];
        let complete = &a[..];    // aに含まれるすべての要素を持つaのスライス
        let middle = &a[1..4];    // 1, 2, 3のみを要素に持つaのスライス
        ```
    - str型：最もプリミティブな文字列型。文字列スライス（&str）として頻繁に使用される。
    - タプル：固定サイズの順序ありリスト
        ```
        let x = (1, "hello");
        let x: (i32, &str) = (1, "hello");
        ```
        分配束縛letを通じて、要素にアクセスできる
        ```
        let (x, y, z) = (1, 2, 3);
        println!("x is {}", x);
        ```
        要素が一つのタプルでは末尾にコンマを付ける
        ```
        let x = (0,); // (i32,) 1要素のタプル
        let y = (0);  // i32 丸括弧に囲まれたゼロ
        ```
        タプルの要素にはインデックスでアクセスできる
        ```
        let tuple = (1, 2, 3);
        let x = tuple.0;
        let y = tuple.1;
        let z = tuple.2;
        ```
- 関数型：関数ポインタ
## コメント
- 行コメント：単純なコメント
    ```
    // コメント
    ```
- ドキュメンテーションコメント：連続した行のコメント
    ```
    /// Markdownが使えるコメント
    /// # コメント
    /// - コメント
    ```
    ```
    //! ファイルへのコメント
    //! クレート、モジュール、関数にコメントを付ける
    ```
